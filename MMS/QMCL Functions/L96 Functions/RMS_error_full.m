%This script runs the complete RMS error average (as outlined in the
%parametrization doc) by running QMDA at L different sequential points and
%then averaging the errors over that entire trajectory

%Variables 
%L - number of QMDA runs (spaced evenly over trajectory)
%N - length of true trajectory 
%QMDA_traj_lengths - number of datapoints generated by each QMDA run
dbstop if error;

L = 40;
N = 10000;
QMDA_traj_lengths = 250;
spectral_res = 600;

%Generate training trajectory
[t,training_spinup] = ode45(@l63_for_ode_solvers,[0:.01:5000],[1.1;0;0]);
training_spinup = transpose(training_spinup);
training_initial = training_spinup(:,500000);
[training_data] = ode4(@l63_for_ode_solvers,[0:.01:((N/100)-.01)],training_initial);
training_data = transpose(training_data);

%Generate true trajectory 
[t,real_spinup] = ode45(@l63_for_ode_solvers,[0:.01:5000],[1;0;0]);
real_spinup = transpose(real_spinup);
real_initial = real_spinup(:,500000);
[real_data] = ode4(@l63_for_ode_solvers,[0:.01:((N/100)-.01)],real_initial);
real_data = transpose(real_data);

%Pick L starting points at equal intervals (store their indices)
interval = (N-QMDA_traj_lengths)/L; 
point_indices = 1:interval:(N-QMDA_traj_lengths);

%Training eigenfunctions on true trajectory 
phi = generate_eigenfunction_basis(training_data, spectral_res);

%Generate QMDA trajectories at each starting points (store in 3d array) 
QMDA_trajectories = zeros(3, QMDA_traj_lengths, L);
for i=1:L
    %QMDA_trajectories(:,:,i) = QMDA_Main_deterministic_equationless(QMDA_traj_lengths, .01, N, real_data(:,floor(point_indices(i))), false, training_data, 0, false, phi, 10, spectral_res);
    QMDA_trajectories(:,:,i) = QMDA_Main_deterministic_RK4(QMDA_traj_lengths, .01, N, real_data(:,floor(point_indices(i))), 0, 1, spectral_res, false, phi, false, training_data, true);
    i
end
%Create averaged error vector (as a function of tau)

real_mini_trajectories = zeros(3, QMDA_traj_lengths, L);
for i=1:L
    real_mini_trajectories(:,:,i) = real_data(:, point_indices(i):(point_indices(i)+QMDA_traj_lengths-1));
end

difference_mat = QMDA_trajectories - real_mini_trajectories;
norm_diff_matrix = sqrt(sum((difference_mat.^2), 1));
error_vec = sqrt((1/L)*sum((norm_diff_matrix.^2), 3));
save("error_vector", "error_vec")

